# Electrical Engineering / Systems Translation

This document is part of a Rosetta Stone for understanding the Plantangenet system. 

## Dust

Plantangenet’s Dust system can be modeled as a **closed, policy-defined electrical network** obeying strict conservation laws analogous to Kirchhoff’s Current Law. Each operational cycle is like a power source pre-charged with a **fixed potential** of Dust--funded in advance to define the exact budget available for that cycle. This ensures no new energy (value) can appear or disappear spontaneously mid-cycle.

Participants function as **nodes** connected by policy-defined **paths** (reference frames) specifying where and how Dust can flow. Executing actions within these frames is equivalent to **drawing current** through components with defined **resistances**--costs that account for not only the direct work performed but also system-level friction such as coordination, validation, and audit overhead. These resistances are explicitly priced in policy to ensure secure, fair, and predictable value flow.

Conservation is enforced at all junctions: the total current (Dust) injected must be completely accounted for in all outputs--work performed, overhead dissipated (like heat), participant holdings, or system reserves. No unmeasured or unintended paths are allowed. Even redistribution mechanisms--such as tips, drift, or forfeitures--are **policy-defined branches** of the circuit, ensuring controlled, auditable flow back to system pools or shared reserves.

Optimization in this model resembles reducing circuit resistance. Participants can redesign workflows to lower coordination overhead, improving the efficiency of Dust flow and maximizing useful work per unit of budget. These savings are retained in the system, boosting value distribution in future cycles.

Ultimately, Dust functions as a **policy-governed power distribution framework**: it requires precise design of potential sources, current paths, and resistances to ensure that all energy (value) is traceable, conserved, and fairly allocated.

> **Note:**
> This circuit model is deliberately closed and policy-defined.
>
> * The total Dust budget per cycle is pre-funded and fixed, like a charged power supply.
> * All paths and resistances are defined in policy.
> * Conservation laws enforce that no Dust is lost or spontaneously created.
> * Costs (resistances) include direct work and systemic overhead.
> * Redistribution mechanisms (tips, drift, expiration) are policy-defined branches returning Dust to reserves.
> * Emergent optimizations reduce resistance but obey conservation and auditability.
> * Audit logs ensure all flows are measured and verifiable.

## Profit

In Plantangenet’s Dust system, **profit** is the measurable surplus energy--net output--generated by designing circuits (workflows) that minimize resistance (friction, overhead, and validation costs) within the closed network.

Profit is **policy-defined and auditable**. Nodes (participants, agents, service providers) can earn profit by delivering work or services more efficiently than the baseline resistance, or by offering convenience, reliability, or bundled functions at a premium. All pricing and flows are governed by the system’s reference frames, which specify allowed paths, resistances, and redistribution branches.

Every transaction records:

- **Voltage applied** (price charged)
- **Current drawn** (actual system cost)
- **Net output** (profit or loss)

Profit is never a hidden leak--it is a planned, tracked outcome, reconciled at every junction. Redistribution mechanisms (fees, tips, shared reserves) are policy-defined branches, ensuring surplus energy is routed transparently to support system sustainability and fairness.

Optimization is rewarded: reducing resistance through better design increases net output, but all flows remain conserved and auditable. The system guarantees that profit for one node is balanced by accounted costs elsewhere, maintaining trust and integrity in the network.

## Policy

In Plantangenet, **policy** acts like a **circuit schematic**: it’s the explicit, enforceable diagram of **how Dust (current) is allowed to flow** through the system.

Every **reference frame** is a path with defined **resistances** (costs), **nodes** (participants), and **junctions** (decision points). Policy is the design spec that:

* Defines who can connect to which node.
* Specifies allowable paths for current (actions).
* Imposes resistance values (prices) for each operation.
* Enforces directionality and conditions (diodes, switches, gating logic).

Policies aren’t passive documentation. They’re **active controllers**, executing **real-time gatekeeping**. Every action is evaluated at runtime:

* Is this path open?
* Is the voltage sufficient (budget available)?
* Are conditions met (role, context, timing)?

Because policy is **modular and pluggable**, you can design anything from **simple linear circuits** (role-based access) to **complex feedback-controlled systems** (context-sensitive, dynamic permissions).

And just like a schematic is **auditable**, Plantangenet policy is **logged and verifiable**. Every decision is traceable, ensuring the entire system remains **predictable**, **secure**, and **transparent** under load.

**Note:**

> Policy is the *blueprint* for Dust flow. It guarantees that coordination is safe, costed, and explicitly designed--no hidden paths or unintended shorts.

## Compositors

**Compositors** in Plantangenet are your **signal transformers** and **circuit interfaces**.

Imagine you have **raw voltage and current signals** (raw data, state graphs, event streams). Compositors are the **filters, amplifiers, and converters** that shape them into **usable, policy-compliant outputs**.

They’re programmable **pipelines** that:

* Apply **transforms** (aggregation, masking, summarization).
* Enforce **access limits** (range, resolution, sampling rate).
* Support **axes**--like frequency channels, spatial regions, or logical dimensions.

Examples for system designers:

* **Graphs for queries** – Compositors as circuit analyzers, mapping connectivity and impedance across large systems.
* **SQL workloads** – Query planners as compositors translating structured inputs to policy-compliant outputs.
* **Axes-frame compositors** – Multi-dimensional data slices with filters applied per policy.
* **Framebuffers** – Rendering UIs with exactly the permitted detail.
* **MLBuffers** – Delivering training batches with masking and degradation enforced.

Compositors support **asynchronous updates** and **dirty-region tracking**, avoiding wasteful recomputation. They ensure **only** the paid-for detail is delivered, maintaining **conservation** of budget while enforcing **negotiated privacy**.

**Note:**

> Compositors are the system’s *signal conditioners*, transforming messy raw data into **clean, policy-shaped, bounded outputs**.

## Squads

**Squads** are Plantangenet’s **distributed subsystems**--modular, coordinated clusters of agents working together under defined budgets and constraints.

Think of them as **subcircuits** on a PCB:

* They contain nodes (agents).
* They’re bounded by specific policy (design rules).
* They control **internal Dust flows** (local currents) while negotiating with the global budget.

**Design use cases:**

* **Tournaments** – Competing agents submitting states, paying for referee adjudication (like arbitration circuits).
* **GAN training** – Generator and discriminator networks exchanging gradients under bounded coordination costs.
* **Systems modeling** – Simulating power networks, chemical reactions, or supply chains with explicit coordination costs.
* **Systems status dashboards** – Aggregating health metrics and logs with bounded Dust budgets for data transfer and rendering.
* **RPG engines** – Multiplayer state machines with enforced rules, turns, and event resolution.

Squads explicitly **pay** for:

* Internal messaging overhead (wiring complexity).
* Validation (parity checks).
* Coordination protocols (synchronization).

By making these costs **visible and budgeted**, squads turn messy service meshes or agent graphs into **designed, auditable subsystems** that can be optimized, analyzed, and improved like real circuits.

**Note:**

> Squads are the *subcircuits* that scale Plantangenet’s system design, enforcing bounded, accountable coordination.

## Membry

**Membry** is Plantangenet’s **state capacitor**--its policy-aware memory layer that ensures **storage is intentional, bounded, and priced**.

Where many systems treat storage as a **free bus** with unbounded fan-out, Membry insists on **declared capacity and lifecycle**:

* All writes are **permissioned** and **priced** (charge accumulation).
* Retention duration is **declared** (discharge rates, leakage models).
* Reads are **filtered or degraded** per policy (voltage dividers).

You can model:

* **Short-term caches** (low-cost, high-volatility).
* **Long-term logs** (expensive, stable, highly audited).
* **Secret vaults** (encrypted, with Dust paid for secrecy level and retention).

**Vaulted storage** behaves like **shielded capacitors**: hidden charge (data) is committed to the ledger (audit logs) without exposing contents, ensuring **accountability without breaking secrecy**.

Designers can implement:

* **Retention policies** – TTL, fading, summarization over time.
* **Access controls** – Who can read, write, modify.
* **Differential costs** – Pricing storage by secrecy, duration, and capacity.

Membry isn’t a store itself--it’s the **control layer** that makes any store behave like a designed circuit, enforcing conservation of Dust while modeling realistic system constraints.

**Note:**

> Membry ensures *storage* is designed as carefully as *logic*, enforcing conservation, accountability, and negotiated retention.

## Privacy & Delivery

In Plantangenet, **privacy** isn’t enforced by secrecy alone. It’s **policy-shaped signal conditioning**:

* Transforming raw data to authorized outputs.
* Masking, degrading, summarizing signals.
* Enforcing negotiated delivery limits.

Imagine privacy as **voltage regulation**:

* High-fidelity detail costs more.
* Low-resolution summaries are cheaper.
* Unauthorized channels are blocked outright.

**Compositors** handle the **transform**:

* TicTacToe example – Board state exposed with only allowed moves, masking player strategy.
* Breakout example – Ball and paddle states shared while internal physics remain private.
* Graph compositors – Local neighborhoods only, with redaction or aggregation.

**Delivery** is managed by **Comdecs**, which are like **output drivers**:

* Streaming approved views to UIs.
* Sending API responses shaped by policy.
* Logging deliveries for audit.

**Janet** is the **plan compiler**:

* Rendering declarative policy and coordination plans.
* Validating, linting, and CI/CD integration.
* Ensuring plans match system-level design rules.

**Meatball** is the **macro-expansion engine**:

* Generating dynamic plans at runtime.
* Supporting conditionals, loops, parametrized modules.
* Guaranteeing safe, predictable expansion.

Together, they ensure **privacy isn’t a bolt-on** but an **integrated design principle**. The system doesn’t just encrypt data--it **controls what is shared, to whom, at what cost**, and ensures all of it is **audited and conserved**.

**Note:**

> Privacy & delivery in Plantangenet are *designed subsystems*, enforcing policy-defined signal transformations and delivery paths with clear, enforceable costs.

## What's a Rosetta Stone?

The Rosetta Stone was an ancient artifact inscribed with the same text in multiple scripts, which enabled scholars to decode Egyptian hieroglyphs by comparing translations. (Wikipedia)

It shows the same system explained in different ways so that different kinds of people can understand it. Each version uses its own words and examples, but they all describe the same system: one with clear rules that makes sure nothing is lost or hidden. By reading these sections, everyone--designers, engineers, players, and organizers--can see how Dust works, how the rules are set, and how all the money or value is tracked and shared fairly.
